1.P2P下载器的作用====》需求定档：让网络上的任意两台主机之间可以互相下载共享文件
2.市场调研：搜一下做这个项目的理由
3.技术调研
4.概要设计：（1）网络上的任意两台主机共享====》必须知道网络上都有哪些主机能够与自己建立共享关系
                   （2）从一个指定的主机上去下载自己想要的文件，也可以将自己的文件提供给别人下载

P2P下载器：
1.包括两大模块（客户端模块----查看有哪些共享主机 + 获取指定主机文件列表 + 从指定主机上下载文件
                          服务端模块----针对客户端的功能能够提供客户端的请求服务）
步骤：1.查看共享主机  2.查看指定主机的共享文件列表 3.下载指定的文件 （过程都是双向的，一台主机既可以是服务器也可以是客户端）

2.概要设计：

3.详细设计：针对概要设计的各个功能点，详细讲解如何实现
                   客户端：（1）查看网络中的共享主机（局域网中的主机配对）
                                        ① 作为客户端，要广播一个主机配对请求，得到响应则认为这个主机在线，可以共享文件（UDP协议自带局域网广播功能，
                                             有可能丢包；而tcp因为没有自带广播功能，所以必须知道所有主机的IP地址，才能发送请求。）
                                        ② 如何获取局域网中所有主机的IP地址： 
                                            IP地址的组成：网络号 + 主机号（0~最大的主机号）
                                            获取网络号：当前主机的IP地址与子网掩码相与
                                            获取最大主机号：子网掩码取反
                                            各个主机的IP地址组成：网络号 + 1 ~ 最大主机号 - 1（不包括0和最大主机号）
                                        ③ 向各个IP地址发送主机配对请求 ---- 网络通信
                                            应用层网络通信协议选择：（①）自定制协议   （②）知名协议 -- HTTP协议（好处：给程序员提供了一定的自定制功能）
                                           （HTTP协议格式：首行 + 头部 + 空行 + 正文）
                                  结果：获取当前局域网中所有在线主机IP地址列表
                                 （2）获取文件列表
                                 （3）客户端就获取了指定主机上的所有共享文件名称
                                 （4）下载指定主机的服务器上的指定共享文件。

4.接口设计：（1）网络主机配对接口（客户端和服务端的）
                             客户端：① 首行：请求方法（GET/POST/PUT，选择GET请求方法）、URL（设置为 /hostpair HTTP/1.1）
                                           ② 头部：Content-Length: 0
                           [首行]           GET /hostpair HTTP/1.1
                           [正文长度]    Content-Length: 0

                             服务器（安装P2P）收到请求，作出响应：① 首行：HTTP/1.1 200 OK （协议版本 状态码 描述信息）
                                                                                                头部：Content-Length: 0
                           [首行]            HTTP/1.1 200 OK
                           [正文长度]     Content-Length: 0

                     （2）获取文件列表接口
                              客户端：
                        [首行]          GET /list HTTP/1.1
                        [正文长度]   Content-Length: 0

             指定主机的服务器：
                        [首行]          HTTP/1.1 200 OK
                        [正文长度]   Content-Length: 
                        [空行]                                                            ------> (检索共享文件夹下的所有文件信息，注意不要目录)
                        [正文]         所有共享的文件名称
                                          filename1\r\nfilename2\r\n...     ------->(使用特殊字符间隔文件名，后期扩展：json序列化，响应给客户端)
                         
                     （3）客户端获取到了指定主机上的所有共享文件名称
                     （4）下载指定主机上的指定共享文件
                              文件下载的接口设计
                              客户端：
                         [首行]           GET /filename HTTP/1.1
                         [正文长度]     Content-Length: 0
                        
                         客户端收到服务端发送过来的文件的数据（作为http的正文）后，创建打开文件，将正文数据写入文件

                               服务器：
                         [首行]           HTTP/1.1 200 OK
                         [正文长度]    Contente-Length: 文件大小
                         [空行]                                                             ------->(服务端收到对方要下载文件之后要：① 这个文件是否存在
                                                                                                                                                                   ② 这个文件如果是个目录，就不给，返回403权限受限等等
                                                                                                                                                                   ③ 正确：读取文件数据作为响应正文)
                         [正文]           正文数据
                         返回给客户端，客户端收到之后创建打开文件，将正文数据写入文件中

5.代码模块设计：
                        ① 获取网卡信息模块（获取到当前主机上的所有网卡信息，通过这些信息，可以获取到当前主机IP地址和子网掩码）
                            //网卡适配器
                            Adapter
                            { 
                                   public:
                                         uint32_t _ip_addr; //网络字节序的IP地址
                                         uint32_t _mask_addr;//子网掩码信息
                             }; 
                            AdapterUtil
                            {
                             #ifdef _WIN32
                                   static GetAllAdapter(std::vector<Adapter>* list); //获取所有网卡信息，返回信息数组
                             #else 
                                   static GetAllAdapter(std::vector<Adapter>* list); //获取所有网卡信息，返回信息数组
                             #endif
                            };
                        ② 客户端代码模块：
                            Client
                            {
                                  public:
                                        //获取在线主机，向所有IP地址发送配对请求，判断是否在线
                                        void HostPair(uint32_t ip); //直接向主机发送请求，判断是否在线（都放在一个线程中，这样并行等待就可以压缩时间了） --- 这是一个线程入口函数（使用C++中的）
                                        //在整体里获取在线的主机列表
                                        bool GetOnlineHost()
                                        { 
                                                 //1.获取网卡信息，得到每个主机IP地址
                                                //2.创建线程，传入HostPair，判断是否在线
                                        }
                                        bool GetShareList(uint32_t ip);//获取指定主机的共享文件列表，打印出来让用户选择要下载的文件
                                        bool DownloadFile(const uint32_t ip, const std::string& filename);//下载文件（下载指定主机上的ip地址 ）
                                 private:
                                        std::vector<uint32_t> _online_host_list; //保存所有的在线主机IP信息  
                            };

                         ③ 服务端模块：
                             Server
                             {
                                    //1.搭建http服务器，对http请求进行业务处理做出响应 --- 使用第三方库实现 - cpp-httplib
                                    //2.针对客户端的功能请求进行业务处理接口的实现即可
                                    void HostPair(); //httplib中针对客户端的主机配对请求做出正确响应
                                    void ShareList();//httplib中针对客户端共享文件列表请求做出正确响应 -- （获取共享目录下的文件信息）
                                    void Download();//httplib中针对客户端文件下载请求做出正确响应 -- （打开文件读取文件数据响应给客户端）
                             };






总体功能流程：
       客户端：
                   1.获取网卡信息 --- 获取主机IP + MASK  ---- 局域网IP列表
                   2.向所有IP发送配对请求 ---- 得到在线主机列表
                      （将在线主机的IP打印到终端，让用户看到）
                   3.选择一个主机（IP）发送获取文件列表请求 ---- 获取到共享的文件列表
                      （将文件列表打印到终端，让用户看到）
                   4.从这个主机（IP）下载指定的共享文件（文件名称）
                        （创建这个文件，打开它，将响应的正文数据写入文件中，关闭它）
        服务端：
                    1.接收到主机配对请求，则做出200响应
                    2.接收到文件列表请求
                                  ① 检测获取指定共享目录下的文件信息（文件名）
                                  ② 将所有文件名组织成为http响应正文
                    3.接收到指定的文件下载请求
                                  ① 通过文件名检测文件是否存在
                                  ② 检测文件是否是一个普通文件
                                  ③ 打开文件，读取文件数据作为http响应正文，响应给客户端












主机字节序（小端）：  192.168.122.132         255.255.255.0    ~（255.255.255.0） = 0.0.0.255
网络字节序（大端）：  132.122.168.192         0.255.255.255    ~（0.255.255.255） = 255.0.0.0
net = 0.122.168.192（网络号）
max_host = 255.0.0.0   0~255.0.0.0   如果数字特别大计算后会比较大，应该转换为小端字节序取反后为0.0.0.255（主机字节序）来进行计算
转换完毕之后：
主机号为 192.168.122.0 + 0.0.0.1 ~ 0.0.0.254





class Client
{};
中在for循环中创建线程 std::thread,实例化出来的对象是一个局部对象，循环下一个就会被释放，无法
在循环之外集中等待。因此在for循环外部创建一个vector<std::thread*> list;
list[i] = new std::thead(&(Client::Hostpair, this); //实例化的线程对象空间中在堆上申请，这样的话for循环运行完，则不会自动释放

当线程的入口函数，是一个类的成员函数的时候，需要注意以上的写法

list[i]->join();等待一个线程的退出

Client
1.实现一个主机的类
class Host
{
     uint32_t _ip_addr;
     bool _pair_ret;
}
2.主机配对三步走：
（1）创建一个vector<Host>，将所有网卡上的所有主机添加到vector中
（2）循环创建线程进行配对，进行配对
（3）循环等待线程退出，通过_pair_ret判断这个主机是否配对成功，若成功则添加到在线主机列表中

主机配对：
作为一个客户端，给其它服务器端发送配对请求
1.自身是一个客户端
2.在应用层选用http协议

1.组织一个http请求数据出来 GET/hostpair HTTP/1.1\r\nContent-Length:0 -> host->ip
2.搭建tcp客户端，与主机建立连接，发送请求数据
3.等待服务端的回复响应，进行解析，判断状态码，200则为配对成功








客户端功能（代码中）：
1.获取在线主机列表，让用户选择：
   （1）获取网卡信息，进而得到局域网中所有的IP地址列表
            ① 这个for循环运行完毕之后，host_list将包含所有网卡的所有的主机的IP地址
   （2）逐个IP地列表中的主机发送配对请求（为了所短时间，使用多线程）‘
            ① 得到每一个主机IP地址（主机号为0的IP地址是网络地址，主机号为1的IP地址是udp广播地址，都不能分配）
            ② 这个主机IP的计算应该使用主机字节序的网络号和主机号（小端字节序）
   （3）等待所有线程主机配对完毕，判断配对结果，若配对请求得到响应，则对应主机为在线主机，将在线主机添加到online_list列表中
            ① 对host_list中的主机创建线程进行配对
   （4）将所有在线主机的IP打印出来，供用户选择
   （5）打印在线主机列表，供用户选择
   
2.获取指定主机共享文件列表，让用户选择
    （1）接口：
             ① req:
                 GET /list HTTP/1.1
                 Content-Length: 0
             ② 
3.下载文件
    （1）接口：
             GET /filename HTTP/1.1
             Content-Length: 0
             响应：
             HTTP/1.1 200 OK
             Content-Length: 文件长度

             文件的数据


**********************************************
网络通信中的文件传输：其实传输的是文件数据
对方打开文件，读取文件数据发送，
接收方创建文件，接收到文件数据，写入文件中
     

设计一个文件操作工具类，目的是为了让外部直接使用文件操作接口即可：
若后期文件操作有其它修改，则只需要修改文件操作工具类，而不需要对原文进行改变
class FileUtil
{
    Write();//向指定文件的指定位置写入指定数据
    bool Write(std::string &filename, std::string & body, int32_t offset)
    bool Read();
};

共享了当前目录下的Shared作为共享目录
   1.判断这个目录是否存在，如果不存在，则需要重新创建
   2.浏览这个目录下的文件信息


则选择使用C++boost库中提供的文件系统接口实现目录浏览，以及文件的各种操作
1.因为系统中默认并不包含boost库，因此需要用户自己安装，然后在项目中引入头文件和库即可


cpp-httplib 是一个C++封装的http库，使用这个库可以完成http客户端/服务端的搭建






**************
httplib的处理流程：
    最简单的http客户端搭建
    1.组织http协议格式的请求数据
    2.搭建tcp客户端
    3.发送组织好的http请求数据
    4.等待服务端响应，接收响应数据
    5.对响应数据进行解析

    最简单的http服务端搭建
    1.搭建最简单的tcp服务器
    2.等待接收客户端发送的数据
    3.按照http协议格式，对数据进行解析（请求方法 URL 协议版本\r\n头部1\r\n头部2\r\n...\r\n\r\n正文）
    4.根据请求的资源路径以及查询字符串以及正文，进行业务处理
    5.组织http协议格式的响应，返回给客户端（协议版本 状态码 描述\r\n头部... \r\n\r\n正文）

httplib中的几个关键类
class Request
{
     std::string method;//请求方法
     std::string path;//请求资源的路径
     map<std::string, std::string> param;//查询字符串，格式key=val
     map<std::string, std::string> headers;//头部信息。格式key: val
     std::string body;//正文 
};

class Response
{
     int status;//状态码，响应给客户端的状态码
     map<std::string, std::string> header;//头部信息
     std::string body;//正文 
};

class Server
{
      //各种请求方法的函数
      Get()
      Post()
      Put()
      ...
      listen(host, port);
};

class Client 
{
      Client(host, port)
      Get()
      Post()
      Put()
       ....    
};



srv.Get(字符串，函数指针)

服务端：
callback(Request& req, Respone& rsp)
{}
int main()
{ 
    httplib::Server srv;
    srv.Get("/", callback);//在服务端添加了一个针对get请求方法以及请求资源的处理方式对应关系
    
    srv.listen("0.0.0.0", 9000);
    //1. 搭建一个监听了本机任意网卡9000端口的tcp服务器
    //2. 等待客户端的连接请求
    //3. 若有新的客户端连接到来，则创建一个线程去处理这个客户端请求
    //4. 在线程中接收数据，进行解析，解析得到的数据放到实例化的Request对象中
    //5. 在之前添加的请求处理方式对应关系中，去检测是否有处理方式，如果有会回调callback函数，
           传入req对象
    //6. 进行callback函数的业务处理，然后填充Response对象rsq
    //7. 将填充的rsq对象数据发送给客户端。
    
}

客户端：
int main()
{
      httplib::Client("服务器IP地址", 端口 = 80)；
      cli.Get("/");//向服务端发送一个资源为'/'的Get请求 
      //1. 组织一个http请求数据
      //2. 搭建一个tcp客户端，将数据发送给服务端
      //3. 等待服务端的响应，并进行解析，将解析得到的数据放入一个实例化的Response对象中。
             通过返回值返回给用户
   
       if(rsp->status == 200)
      {
           rsp->body = 响应的正文;
           rsp->headers = 响应头部信息
      }    
}







测试工具：
MD5验证源文件与下载的文件是否一致
MD5 --- 对文件的所有内容进行运算，最终得到一个32个字节的字符串
先计算源文件的，然后再计算下载的文件的
若下载的文件的MD5与源文件的MD5不同，则表示两个文件内容不同
windows下计算文件MD5的命令：certutil -hashfile filename md5
当前我们的下载功能已经完成，但是有一个问题就是文件下载之后，源文件与
下载的文件文本完全一致，但是文件大小不同，MD5不同，文件并不一致，当
前怀疑是windows字符编码的问题。（宽字符的问题）
问题解析：使用C++标准库进行文件操作的时候。默认是文本操作，会涉及到字符编码集的宽字符
问题，因此导致读取的数据与写入的数据不同（读取一个字符，但是一个字符可能会占据两个字节，
只是按照字符一个字符读取）。对文件进行文本操作时，则内存中两个字节的字符实际只读取了一个字节
解决方案：进行文件读写操作的时候，打开文件的时候就以二进制方式文件进行操作

以后对文件进行操作的时候要注意二进制/文本操作的不同之处。

Beyond Compare工具：用来对比两个文件的不同之处，然后不同的地方用红色标出










断点续传：
网页上的断点续传其实都是通过分块下载完成的
主要了解一下分块下载如何实现的？







断点续传：当正在下载文件的时候，突然网络中断，导致文件没有下载完毕而失败，等到下次网络通畅的时候，
                 可以继续从上次断开的位置开始下载文件，而不需要重新将完整的文件下载一次，来提高异常情况下
                 文件的传输效率。原理和分块传输完全一样，只是少量将当前的传输信息记录起来这一步。主要依靠
                 HTTP协议中的Range字段，告诉服务器当前请求的数据范围

文件下载过程中，单独起一个文件，每隔一会就记录一下当前已经下载了多少数据，这时候如果网络断开，
下次下载就知道从哪里下载了。

下次继续下载的时候，就需要告诉服务端，到底应该从哪里开始传输，这样服务端知道了从哪里开始传输
数据，就不需要对以前已经传输过的数据重新二次传输了

我们程序员需要了解的就是分块传输（告诉对方要传输什么数据，从哪里开始，到哪里结束，有多少）的协议
格式到底是什么样的



断点续传比分块传输多了一个临时文件，用来记录断开的位置信息



HTTP协议在传输数据的时候支持断点续传（分块传输）
协议头中的Range字段：区间（就是告诉我们从哪开始到哪结束）
Range请求报头指示该服务器应该返回文档的一部分，可以一次请求一个Range头部的多个部分,服务器可以在
多部分文档中返回这些范围，如果服务器发回范围，它使用206 Partial Content该响应（200是整个文件的响应），如果范围无效，则服务器
返回416 Range Not Satisfiable错误。服务器也可以忽略Range标题并用200状态码返回整个文档。

用法：Range: bytes = 200-1000 （告诉服务器想要文档从第200个字节到第1000个字节区间的数据，共801个字节的长度）
  或者 Range: bytes = 19000-（告诉服务器想要文档从第19000个字节到文档末尾的区间的数据）



客户端请求
GET /filename HTTP/1.1
Range: bytes=100-
服务端的响应：假设文件大小1000字节
HTTP/1.1 206 Partial Content
Content-Range: bytes 1000


暂时不实现断点续传，但是会使用分块传输
因为：当前我们的文件传输都是一次性读取文件数据/一次性向文件写入数据
          相当于定义了一个与文件大小相同的buff，这时候如果文件大小非常大（4G/10G），则会造成严重问题
          1.内存有点吃紧不够用，则会大量使用交换内存（交换分区），而这种大量的内存交换会造成效率低下
          2.内存耗尽，程序崩溃
          为了解决这种问题，最好使用分块传输（每次只向服务器请求文件的一部分）
比如：一个4G的文件，可以分10块来请求下载，每块就只有400M，相当于每次只占用400M内存，这是完全无压力的


定义：若文件大小超过了100，则进行分块传输
          若文件大小150M，分成两块下载--------也要注意，数据要写入文件的位置。
      
          GET /filename HTTP/1.1                             GET /filename HTTP/1.1
         Range: bytes=0-100M                                Range: 100M-

定义：若文件大小超过了100字节，则进行分块传输
          若文件大小336字节，分块下载
      
          GET /filename HTTP/1.1                            
         Range: bytes=0-99                            

          GET /filename HTTP/1.1
          Range: bytes=100-199

         GET /filename HTTP/1.1
         Range: bytes=200-299
 
         GET /filename HTTP/1.1
         Range: bytes=300-


想要实现分块传输，首先的知道文件有多大，然后才知道如何分块

HEAD /filename HTTP/1.1
HEAD：只要响应头信息，而不要内容，通过响应头部中的Content-Length知道正文有多长（文件大小）


DownloadFile()
{
      1. 发送HEAD请求，得到响应，获取到文件大小
      2. 根据定义的块大小对文件进行区间分块
      3. 循环请求分块数据，一块响应成功了再请求下一块

}

if(size % range == 0) //若size刚好整除了range
      num = size/range;
else
      num =size / range + 1
for(int i = 0; i < num; ++i)
{
     start = i*range;  // end最后一个分块文件大小-1
     if(i == (num - 1))
           end = size - 1;
     else
           end = (i + 1)*range - 1;

}



******************************************************************************************
针对在httplib中，Get接口不但针对客户端的GET请求方法，还针对客户端的HEAD请求方法





网络穿透：（UDP打洞技术）
当前我们所写的P2P程序是一个局域网的P2P，无法实现整个网络的P2P
因为局域网之间无法跨网络进行数据传输（因为局域网中主机都是用的时候私网地址，并且经过了NAPT映射之后才开始通信的）
就算我们知道对方的私网地址，但是因为我们并没有网络，因此无法直接通信
如果局域网之间想要进行通信就要借助网络穿透技术实现，让两个局域网主机之间不需要经过一个中转
服务器进行数据转发而实现通信，该技术就是网络穿透。
网络穿透的实现原理：同样需要借助一个公网服务器，但是这个公网服务器并不实现数据的转发，
                                 主要首先让服务器，向公网服务器发送请求，我们的主机到连接公网的路由器
                                 之间就会建立层层的NAPT映射关系，并且公网路由器就知道了当前服务器所对应
                                 的公网地址以及端口，其它的客户端同样也在访问服务器之前去访问公网服务器，获知，
                                 局域网服务器对应的那个连接公网路由器的地址信息。然后这个客户端再向这个局域网
                                 服务器对应的外网地址发送请求。。。因为之前局域网服务器法发送数据的时候，在整个
                                 公网之间的路由器上都建立了NAPT映关系，因此发送到指定的这个局域网服务器对应的
                                 外网地址，就会逐层最终发送到这个局域网服务器上。（首先让公网路由器向公网服务器发送请求，
                                 公网服务器返回给它另一个公网路由器的地址，然后该公网服务器就可以和另一边的公网服务器之间
                                 进行公网间之间传输，然后逐层发送到局域网服务器中）







项目的面试概要：
（1）为什么要写这个项目
（2）你的项目为什么跟上个同学一样
（3）给项目起个好听的名字
（4）介绍一下所做的项目：① 开发环境/运行环境
                                          ② 项目简介，是干什么的
                                          ③ 实现的流程/模块的功能
如：是一个可以跨windows以及Linux平台的一个P2P下载项目，这个项目实现了不同主机之间的文件共享
       主机可以直接做在线主机，下载共享文件。
       模块化介绍（Tools模块、Client模块、Server模块各自实现了什么功能）

（5）项目中的技术点：
         tcp不能进行广播。因此需要获取到所有主机IP地址
         C++STL库（vector、httplib中的multimap（用来存储键值对的、底层、特性））、IP地址管理、boost库文件操作、网络传输、HTTP协议、tcp协议、多线程、文件的分块传输、boost库中的一些目录操作以及其它文件相关操作、
（6）当前的P2P是一个局域网的，不同局域网如何实现------网络穿透技术
（7）做的这个项目有什么扩展点   ------- ① 跨网络 
                                                               ② 公网服务器提供的这种快速获取各个主机信息的方式 
                                                               ③ 断点续传 
                                                               ④ epoll多路转接技术实现总线时间监控
                                                               ⑤ 视频的直接点播和图片的直接查看
                                                               ⑥ 用云服务器集中对文件列表进行管理，所有人上来就可以从这里获取文件列表，并且可以查看谁跟谁有相同文件
                                                                    实现不同主机上的分块请求，所有主机可以先访问云服务器，看谁在线，谁有哪些文件，实现一对多的传输。
（8）做这个项目过程中都遇到了哪些问题以及如何解决的
         ① 主机匹配速度过慢 -------》  采用多线程   ------- 线程过多的资源问题  =====》线程池  （httplib中使用了多线程）
         ② 文件操作时的默认的文本操作与二进制操作之间的不同
         ③ 当前实现http服务器使用的httplib实现的，观察过源码之后发现直接将
              文件所有数据一次性拷贝进入内存进行传输。内存消耗比较高、在传入大文件的时候
              容易产生内存交换或者资源耗尽程序崩溃 ----- 解决方案 ：采用分块传输，分块大小是基于什么原因考虑的
               a.内存不够，因此产生了大量的内存交换，极大的降低了效率
               b.内存不够，程序直接崩溃
             一开始分多少块，就启动多少线程，并没有解决实际问题，后来采用了线程池，限制了同一时间所能发送的请求数以及避免同一时间占用内存
            过多的情况     

 
（9）测试项目：局部测试（针对客户端、服务端模块的每个模块功能进行测试）测试、系统测试、性能测试 （40、50M的下载速度）webbench
                         功能测试：功能是否都完成，没有问题
                         性能测试：服务端通信能够同时与多少客户端进行数据通信；文件传输性能有多高
                                          我使用了webbench（性能压力测试，就是HTTP客户端启很多进程不断给服务端发送连接）测试工具对链接数进行了测试，因为我虚拟机或云服务器的资源限制，当前可以连接23（20-30）个，再多就会连接失败
                        文件传输性能这里，我在程序中打了log，对文件的传输起始以及结束进行了时间统计分析，一个客户端传输46M/s
                    









简历中的项目的编写
项目名称：
项目简介：
开发环境：
模块/流程实现：
          ....模块1：基于什么技术封装实现了什么功能
           网络传输模块：使用httplib库实现网络通信中HTTP服务器以及客户端的搭建
           文件操作模块：基于boost库中的文件操作，实现指定目录下文件信息迭代获取
           文件分块下载模块：基于线程池，实现下载文件时，将文件的所有数据下载进行分块传输
项目链接：github







httplib中是用了多线程


















int main(int argc, char* argv[])
{
     if(argc != 3)
     {
          std::cout << "./tcp_srv ip port\n";
          return -1;
     }

     std::string ip = argv[1];
     uint16_t port = atoi(argv[2]);
     
     socket lst_sock;
     lst_sock.socket();
     lst_sock.bind(ip, port);
     lst_sock.listen();
     
     socket cli_sock;
     while(1)
     {
            std::string cli_ip;
            uint16_t cli_port;
            if(lst_sock.accept(& cli_sock, &cli_ip, &cli_port) == false)
                   continue;
            std::cout << "new connect :" << cli_ip << " : " << cli_port << "\n";
             
            std::string buf;
            bool ret = cli_sock.recv(buf);
            if(ret == false)
            {
                    cli_sock.close();
                    continue;
            }
            std::cout << "client say : " << buf << "\n";
            std::cout << "server say:" ;
            fflush(stdout);
            buf.clear();
            std::cin >> buf;
            ret = cli_sock.send(buf);
            if(ret == false)
            {
                  cli_sock.close();
                  continue;
            }
     }

     lst_sock.close();
     return 0;
}