
一面
https过程



多线程编程要考虑什么

1. 如何控制线程的调度和堵塞，例如利用事件的触发来控制线程的调度和堵塞，也有用消息来控制的 实现同步与互斥
2. 线程中如果用到公共资源，一定要考虑公共资源的线程安全性。一般用LOCK锁机机制来控制线程安全性，一定要保证不要有死锁机制
3. 线程的终止一般要使线程体在完成一件工作的情况下终止，一般不要直接使用抛出线程异常的方式终止线程
 
加锁时要考虑什么

1. 加锁的时候要考虑范围，避免逻辑错误，造成锁住不该锁的东西，降低程序的运行效率
2. 对全局变量，多线程都能访问到的，防止访问修改错误的时候要用到互斥锁，加锁时要考虑什么
3. linux下 禁止对同一互斥锁进行加锁两次以上的操作，会形成递归锁

TCP连接如何建立

	三次握手建立连接。

bind和listen分别做什么


accept怎么建立新的连接

算法题：K个数组合并

connect()函数 ： 为客户端主动连接服务器，建立连接是通过三次握手，而这个
连接过程是由内核完成的，不是这个函数完成的，这个函数的作用仅仅是通知linux内核
让linux内核完成 TCP 三次握手连接，最后把连接的结果返回个这个函数的返回值(成功返回0，失败返回1)


listen(): 函数的主要作用是 将套接字(sockfd) 变成被动的连接监听套接字，至于参数
blocklog 的作用是设置内核中连接队列的长度，
TCP 三次握手也不是由这个函数完成，listen()的作用仅仅告诉内核一些信息。
！！！ listen()函数不会阻塞，它主要做的事情为，将该套接字和套接字对应的连接队列长度告诉 Linux 内核，然后，listen()函数就结束。

！！！当有一个客户端主动连接（connect()），Linux 内核就自动完成TCP 三次握手，将建立好的链接自动存储到队列中，如此重复
所以，只要 TCP 服务器调用了 listen()，客户端就可以通过 connect() 和服务器建立连接，而这个连接的过程是由内核完成。


三次握手的连接队列
这里详细的介绍一下 listen() 函数的第二个参数（ backlog）的作用：告诉内核连接队列的长度。



为了更好的理解 backlog 参数，我们必须认识到内核为任何一个给定的监听套接口维护两个队列：

1、未完成连接队列（incomplete connection queue），每个这样的 SYN 分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的 TCP 三次握手过程。这些套接口处于 SYN_RCVD 状态。


2、已完成连接队列（completed connection queue），每个已完成 TCP 三次握手过程的客户对应其中一项。这些套接口处于 ESTABLISHED 状态。


当来自客户的 SYN 到达时，TCP 在未完成连接队列中创建一个新项，然后响应以三次握手的第二个分节：服务器的 SYN 响应，其中稍带对客户 SYN 的 ACK（即SYN+ACK），这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器 SYN 的 ACK ）到达或者该项超时为止（曾经源自Berkeley的实现为这些未完成连接的项设置的超时值为75秒）。



如果三次握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。


accept()函数
accept()函数功能是，
从处于 established 状态的连接队列头部取出一个已经完成的连接，如果这个队列没有已经完成的连接，accept()函数就会阻塞，直到取出队列中已完成的用户连接为止。


如果，服务器不能及时调用 accept() 取走队列中已完成的连接，队列满掉后会怎样呢？UNP（《unix网络编程》）告诉我们，服务器的连接队列满掉后，服务器不会对再对建立新连接的syn进行应答，所以客户端的 connect 就会返回 ETIMEDOUT
二面
算法题：LFU，两个日期相隔天数
项目
Python gc
网络编程会吗
为什么需要虚拟内存
LRU和LFU是什么，页面置换算法用的哪一个？
专业课排名怎么样
最大的优点和缺点
